# -*- coding: utf-8 -*-
"""Copy of Hahn Math 24 Lab 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11v75nVOIC_g6dnB8UDm7-FkHMgfo5QDl

#Monte Carlo
"""

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-3,3,100)
#creates an array of 100 equally spaced values between -3 and 3 using NumPy’s linspace function.

y = x**2 + 2
#function for y in terms of x

plt.plot(x,y)
#plots y v.s. x

#this is significant because the area under the curve gives probabilities of specific events.

"""$f(x) = x^2 + 2$

$Area = \int_a^bf(x) dx$

$= \int_a^b (x^2+2) dx$

$= \left.\frac{x^3}{3}+2x\right\vert_1^2$

$= (\frac{8}{3}+4) - (\frac{1}{3}+2)$

$= \frac{13}{3}$
"""

13/3

"""To integrate the function $f(x)$ over the interval $[a,b]$ we

[1] find some value $M$ such that $f(x) < M$ over the interval $[a,b]$

[2] select a random number $x$ from a uniform distribution over the interval $[a,b]$

[3] select a random number y from a uniform distribution over the interval $[0,M]$

[4] determine if $y > f(x)$ or $y ≤ f(x)$

[5] repeat this process $N$ times, keeping track of the number of times $y ≤ f(x)$ or under the curve, successes $S$.

The estimated probability of success is then:

$\frac{S}{N}=\frac{\text{Area under curve}}{\text{Total area inside rectangle}} = \frac{\int_a^bf(x)dx}{M(b-a)}$

$\int_a^bf(x)dx = M(b-a)\frac{S}{N}$

summary: the equation relates the definite integral to the mean value of the function and the subinterval width. It’s a fundamental concept in calculus, allowing us to find areas, averages, and other important quantities
"""

plt.plot(x,f(x))
#resulting plot visually represents the relationship between (x) and (f(x))

def f(x):
    y = x**2 + 2
    return y
# defines a function named f(x) that computes the value of (y = x^2 + 2) for a
# given input (x). When called with an argument (x), the function returns the corresponding (y) value.

M = 10
#defines variable

a = 1
b = 2
#variable definitions

x = a + (b-a)*np.random.random()
#generates a random number between the values of ‘a’ and ‘b’  and assigns to x

x
#displays the value of x

y = M*np.random.random()
#This  generates a random value between 0 and 1 using np.random.random()
#and then scales it by a constant M.
#The result is assigned to the variable y.

x,y,f(x)
#displays the respective values in an array.

y < f(x)
#checks whether the equality is true or false

N = 100_000 #represents the number of iterations or random points we will generate.
S = 0 #a counter variable (S) to keep track of how many points fall below the curve (f(x))
for i in range(N):
#iterates through a loop (N) times (from 0 to (N-1))
    x = a + (b-a)*np.random.random() #generates a random x value within the ([a,b])interval
    y = M*np.random.random() #generates a random y value scaled by M

    S += (y < f(x))
#checks if the randomly generated point ((x, y)) lies below the curve (f(x)).
# If yes (i.e., (y < f(x))), increment the counter (S)
M*(b-a)*(S/N)
# represents an estimated area under the curve of the function (f(x)) using a Monte Carlo simulation approach.

def f(x):
    y = x**2 + 2
    return y
# defines a function named f(x) that computes the value of (y = x^2 + 2) for a
# given input (x). When called with an argument (x), the function returns the corresponding (y) value.

def monte_carlo_integrate(f,a,b,N):
#estimates the definite integral of the function (f(x)) over the interval ([a, b]) using the Monte Carlo method

    N = 10000000 #increased value for N
    S = 0
    for i in range(N):

        x = a + (b-a)*np.random.random()
        y = M*np.random.random()

        S += (y < f(x))

    return M*(b-a)*(S/N)
#This increased precision results in a more accurate estimate of the integral.

monte_carlo_integrate(f,1,2,1000)
#evaluates for the given values

from sympy import *
# imports the SymPy library into the Python environment which is a powerful Python library for symbolic mathematics

x = Symbol('x')
#defines x as a string.

x

integrate(x**2 + 2, (x,1,2))
#represents the definite integral of the function (f(x) = x^2 + 2) over the interval ([1, 2]).
#The numerical value obtained from evaluating this integral will give us the exact area under the curve of (f(x)) between (x = 1) and (x = 2)

13/3

integrate(x**3 + 3, (x,1,2))

27/4

x = 0

def f(x):
    y = x**3 + 3
    return y
#creates a new function while redefining the equation for y used previously

monte_carlo_integrate(f,1,2,1000)
#estimates the definite integral of a given function (f(x)) over the interval ([1, 2]) using the Monte Carlo method
#Monte Carlo method uses random points to estimate the integral of a function.
#The more points generated (larger (N)), the more accurate the estimate becomes



N = 2000 #new value for N
S = 0
Z = np.zeros(N,) #To create an array of zeros with (N) elements.
#This array will store intermediate results during the Monte Carlo simulation.
for i in range(1,N):

    x = a + (b-a)*np.random.random()
    y = M*np.random.random()

    S += (y < f(x))

    Z[i] = M*(b-a)*(S/i)
#The final result is not directly computed here. Instead, the array (Z) contains intermediate estimates of the integral at different stages of the simulation.
#The value of (Z[N-1]) (the last element of the array) will be the final estimate of the integral using the Monte Carlo method.

plt.plot(Z) #plots the array z
#The x-axis represents the number of iterations, and
#the y-axis represents the intermediate estimates of the integral using the Monte Carlo method.
plt.plot(6.75*np.ones(Z.shape))
#This line adds a horizontal dashed line at the value (y = 6.75).
#This represents the true value of the integral



import numpy as np
import matplotlib.pyplot as plt
from sympy import Symbol, integrate

# Define a general function for Monte Carlo integration
def monte_carlo_integrate(func, a, b, N, M):
#estimating the definite integral of a given function using the Monte Carlo method.
    S = 0
    for _ in range(N):
        x = a + (b - a) * np.random.random()
        y = M * np.random.random()
        if y < func(x):
            S += 1
    return M * (b - a) * (S / N)

# Define the functions to be integrated
def f1(x):
    return x**2 + 2

def f2(x):
    return x**3 + 3

# Calculate exact and estimated areas
def calculate_areas(func, a, b, N, M):
    x_sym = Symbol('x')
    exact_area = integrate(func(x_sym), (x_sym, a, b)).evalf()
    estimated_area = monte_carlo_integrate(func, a, b, N, M)
    return exact_area, estimated_area
#The code calculates both the exact area (using symbolic integration) and
#the estimated area (using Monte Carlo simulation) under each function within the interval ([1, 2]).

# Plotting function
def plot_function(func, title, a=-3, b=3):
    x = np.linspace(a, b, 100)
    y = func(x)
    plt.plot(x, y, label=title)
    plt.title(title)
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.legend()
    plt.show()

# Plot the functions
plot_function(f1, "$f(x) = x^2 + 2$")
plot_function(f2, "$f(x) = x^3 + 3$")

# Calculate and print areas
exact_area_f1, estimated_area_f1 = calculate_areas(f1, 1, 2, 100000, 20)
exact_area_f2, estimated_area_f2 = calculate_areas(f2, 1, 2, 1000000, 20)

print("Exact Area under f1:", exact_area_f1)
print("Estimated Area under f1:", estimated_area_f1)
print("Exact Area under f2:", exact_area_f2)
print("Estimated Area under f2:", estimated_area_f2)
#Comparing these values demonstrates the effectiveness of the Monte Carlo method for numerical integration.
#this code showcases how to estimate areas under curves using Monte Carlo integration and provides a visual representation of the functions being analyzed





"""# Visualization"""

# Function to plot points for Monte Carlo integration
def plot_monte_carlo(func, a, b, M, N):
#This function generates random points for Monte Carlo integration visualization.
    x_points = a + (b - a) * np.random.random(N)
    y_points = M * np.random.random(N)
    below = y_points < func(x_points)
    above = np.invert(below)

    # Plotting the function
    x = np.linspace(a - 1, b + 1, 400)
    y = func(x)
    plt.plot(x, y, label="f(x)", color='black')

    # Plotting the points
    plt.scatter(x_points[below], y_points[below], color='green', label='Points below f(x)')
    plt.scatter(x_points[above], y_points[above], color='red', label='Points above f(x)')
#Points below the curve are shown in green.
#Points above the curve are shown in red.
    # Setting up the plot limits and labels
    plt.xlim(a - 1, b + 1)
    plt.ylim(0, M)
    plt.xlabel("x")
    plt.ylabel("y")
    plt.title("Monte Carlo Integration Visualization")
    plt.legend()

    plt.show()

# Function to be integrated
def f(x):
    return x**2 + 2

# Parameters for Monte Carlo Integration
a, b, M, N = 1, 2, 20, 1000

# Plotting the Monte Carlo Integration
plot_monte_carlo(f, a, b, M, N)

#The visualization helps us understand how the Monte Carlo method estimates the area under the curve.



# Function for Monte Carlo Integration
def monte_carlo_integrate(func, a, b, N, M):
#estimating the definite integral of a given function using the Monte Carlo method.
    S = 0
    for _ in range(N):
        x = a + (b - a) * np.random.random()
        y = M * np.random.random()
        if y < func(x):
            S += 1
    return M * (b - a) * (S / N)

# Function to be integrated
def f(x):
    return x**2 + 2
#This is the curve we want to find the area under.

# Parameters
a, b, M = 1, 2, 20
iterations = np.logspace(1, 6, 100, dtype=int)  # Using logarithmically spaced iterations for smoother curve
#The number of iterations ((N)) varies logarithmically from 10 to 1,000,000.
estimated_areas = []

# Calculate estimated areas for different numbers of iterations
for N in iterations:
    estimated_area = monte_carlo_integrate(f, a, b, N, M)
    estimated_areas.append(estimated_area)
#The estimated area becomes more accurate as the number of random points generated increases.
# Plotting convergence
plt.figure(figsize=(10, 6))
plt.plot(iterations, estimated_areas, color='blue')
plt.xscale('log')
plt.xlabel('Number of Iterations (log scale)')
plt.ylabel('Estimated Area')
plt.title('Convergence of Monte Carlo Integration')
plt.grid(True)
plt.show()
# this code demonstrates the convergence behavior of the Monte Carlo method for
# numerical integration and provides insights into how accurate the estimates become with more iterations



