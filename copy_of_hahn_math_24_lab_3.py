# -*- coding: utf-8 -*-
"""Copy of Hahn Math 24 Lab 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wtzu8xQZWfQAygQzGGDtUV30RlaFmTM4
"""

import numpy as np
import matplotlib.pyplot as plt

"""# Normal Random Number Generator"""

#CDF PDF

x = np.linspace(-10,10,1000)
#It generates an array of 1000 equally spaced points between -10 and 10
y = 2.71**(-x**2)
#It calculates the corresponding y-values
plt.plot(x,y)
#plots the x and y values

"""$e^{-x^2}$

![alt text](https://wikimedia.org/api/rest_v1/media/math/render/svg/4abaca87a10ecfa77b5a205056523706fe6c9c3f)
"""

def normal_pdf(x,mu,sigma):

  return (1/(np.sqrt(2*np.pi*sigma**2)))*np.exp((-(x-mu)**2)/(2*sigma**2))
#The given function calculates the probability density function (PDF) of a normal distribution (Gaussian distribution) at a given value (x), with mean (mu) and standard deviation (sigma)

x = np.linspace(-6,6,1000)
#generates an array of 1000 equally spaced values between -6 and 6

x
#displays the array

mu = 0

sigma = 1

pdf = normal_pdf(x,mu,sigma)
#calculates the probability density function (PDF) of a normal distribution at a specific value (x), with a given mean (mu) and standard deviation (sigma)

plt.plot(x,pdf,'.') #creates a scatter plot of the calculated PDF values (stored in the variable pdf) against the corresponding x values.
#The ‘.’ specifies that each data point should be represented as a dot.
# plt.plot(x,y,'g.')

n= 5 #assigns the value 5 to the variable n.
x[0:n] #extracts and creates a new array containing the first 5 elements of x.
np.sum(x[0:n]) # calculates the sum of the elements in the x_subset array

def cumulative_sum(x):

  y = np.zeros(x.shape)

  for n in range(x.shape[0]):

    y[n] = np.sum(x[0:n])

#   y = y / np.max(y)

  return y
#calculates the cumulative sum of an input array (x).
#It initializes an array (y) with zeros, then iterates through the elements
#of (x), adding up the values from the beginning to the current index.
#The resulting array (y) contains the cumulative sum of (x) at each position.

z = np.array([1,2,3,4,5])
#creates a NumPy array named z containing the values 1, 2, 3, 4, and 5

z
#displays z

cumulative_sum(z)
#calculates the cumulative sum of an input array z.

cdf = cumulative_sum(pdf)
#uses the previously defined function cumulative_sum to compute the cumulative sum of the PDF values stored in the variable pdf

plt.plot(x,cdf,'.');
#creates a scatter plot of the cumulative distribution function (CDF) values against the corresponding x values.

# d_cdf = cdf[1:] - cdf[0:-1] #Demo to show that the derivative of the cdf gives you back the pdf
# plt.plot(x[1:],d_cdf,'.');  #Not required for sampling

plt.plot(cdf,x,'.');
#plots the inverse graph.

def find_nearest(array, value):

  idx = np.argmin(np.abs(array - value))

  return idx
# calculates the index of the element in the input array that is closest to the specified value.
#It achieves this by finding the element with the smallest absolute difference from the target value.

z = np.array([11.2,32,63,4.3,5.67])
#creates a NumPy array named z containing the specified values

find_nearest(z, 22.1)
#This function calculates the index of the element in the array z that is closest to the specified value 22.1.

z[1]
#provides the value of the array in the first position after the zero position

find_nearest(cdf, 0.1)
#This function calculates the index of the element in the CDF array that is closest to the specified value 0.1

x[393]

xr = np.random.random((10000,))
#creates an array where each element in the array represents a random value sampled uniformly from the interval [0, 1)

r = np.random.random()
#generates a random number between 0 (inclusive) and 1 (exclusive)

r

x[find_nearest(cdf, r)]
#finding the index of the nearest cumulative probability in the cdf array
#and then retrieving the corresponding value from x.

w = np.zeros(xr.shape[0])
#initializes an array (w) with zeros, having the same length as the array (xr).
for i in range(xr.shape[0]):
#Iterates through each element in (xr).
  w[i] = x[find_nearest(cdf, xr[i])]
#Retrieves the corresponding value from the array (x) and assign it to the corresponding position in (w).

w.shape
#indicates the number of elements in the array w

plt.hist(w,50);
#generates a histogram of the array w with 50 bins.

num_bins = 50 #This line sets the number of bins for the histogram to 50.
n,bins,patches = plt.hist(w, num_bins, density=1) #creates a histogram of the array w with 50 bins, normalized to form a probability density. The resulting arrays n and bins contain the histogram values and bin edges, respectively.
y = ((1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-0.5 * (1 / sigma * (bins - mu))**2)) #calculates the theoretical probability density function (PDF) for a normal distribution with given mean mu and standard deviation sigma
plt.plot(bins,y) #overlays the theoretical PDF (normal distribution) on the histogram plot.





"""# Homework

# Birthday Paradox
"""

import random

def simulate_birthday_paradox(people, simulations):
    matches = 0
#The function initializes a counter called matches to keep track of the number of simulations where there was a birthday collision.
    for i in range(simulations):
        birthdays = [random.randint(1, 365) for _ in range(people)]
        if len(birthdays) != len(set(birthdays)):
            matches += 1
#For each iteration, it generates a list of (people) random birthdays (represented as integers from 1 to 365, inclusive).
#If there are duplicate birthdays (i.e., the length of the list is not equal to the length of the set of unique birthdays), it increments the matches counter.
    probability = matches / simulations
    return probability
#The function calculates the probability of a birthday collision by dividing the number of matches by the total number of simulations.

# Number of people in the room
people = 100

# Number of simulations
simulations = 10000

# Calculate the probability
probability = simulate_birthday_paradox(people, simulations)
probability
#with 100 people and 10,000 simulations, it returns the estimated probability.



"""# Monty Hall"""

#This function simulates the Monty Hall problem.
def simulate_monty_hall_final(simulations):
    wins_switching = 0
    wins_staying = 0

    for _ in range(simulations):
        # Randomly assign the car to a door (1, 2, or 3)
        car_door = random.randint(1, 3)
        # Player makes an initial choice
        player_choice = random.randint(1, 3)

        # Host opens a door, which is neither the player's choice nor the car door
        for host_choice in [1, 2, 3]:
            if host_choice != car_door and host_choice != player_choice:
                break

        # Find the remaining door for the player to switch to
        for switch_choice in [1, 2, 3]:
            if switch_choice != player_choice and switch_choice != host_choice:
                break

        # Count the number of wins for staying with the initial choice
        if player_choice == car_door:
            wins_staying += 1

        # Count the number of wins for switching to the other door
        if switch_choice == car_door:
            wins_switching += 1

    # Calculate the probabilities of winning by staying and switching
    probability_staying = wins_staying / simulations
    probability_switching = wins_switching / simulations

    return probability_staying, probability_switching

# Running the final version of the simulation
final_probability_staying, final_probability_switching = simulate_monty_hall_final(simulations)
final_probability_staying, final_probability_switching

#This result demonstrates the counterintuitive nature of the Monty Hall problem,
#where switching doors significantly increases the chances of winning.



"""# Simple Craps"""

#The provided code defines a simulation of the Dice Game, which is based on the rules of the popular dice game “Craps.”
def simulate_dice_game(simulations):
    wins = 0

    for _ in range(simulations):
        # Roll two six-sided dice
        roll = random.randint(1, 6) + random.randint(1, 6)

        # Check for immediate win or loss
        if roll in [7, 11]:
            wins += 1
            continue
        elif roll in [2, 3, 12]:
            continue

        # Save the initial roll
        initial_roll = roll
#If neither win nor loss occurs, the initial roll value is saved.
        # Re-roll phase
        while True:
            roll = random.randint(1, 6) + random.randint(1, 6)
            if roll == 7:  # Loss condition
                break
            elif roll == initial_roll:  # Win condition
                wins += 1
                break
#Continues rolling the dice until either:
#The sum is 7 (loss condition), in which case the loop breaks.
#The sum matches the initial roll value (win condition), and the (wins) counter is incremented.

    probability_of_winning = wins / simulations
    return probability_of_winning
#Calculates the probability of winning by dividing the number of wins by the total number of simulations.

# Number of simulations
simulations = 10000

# Calculate the probability
probability_of_winning = simulate_dice_game(simulations)
probability_of_winning
#This simulation demonstrates the probabilities associated with the game of Craps.

"""# Collector's Card Paradox

"""

#This function simulates the process of collecting a set of (n) different characters by buying card packs.
def simulate_card_collectors_problem(n, simulations):
    total_card_packs_bought = 0
#Initializes a counter called (total_card_packs_bought) to keep track of the total number of card packs purchased across all simulations.

    for _ in range(simulations):
        collected_characters = set()
        card_packs_bought = 0
#Initializes an empty set called (collected_characters) to track the characters collected.
#Initializes a counter called (card_packs_bought) to count the number of card packs bought in this simulation.

        # Buy card packs until all characters are collected
        while len(collected_characters) < n:
            new_card = random.randint(1, n)
            collected_characters.add(new_card)
            card_packs_bought += 1

        total_card_packs_bought += card_packs_bought

    # Calculate the average number of card packs needed
    average_card_packs_needed = total_card_packs_bought / simulations
    return average_card_packs_needed

# Number of different characters
n = 10

# Calculate the expected number of card packs
expected_card_packs = simulate_card_collectors_problem(n, simulations)
expected_card_packs
#This simulation models the classic problem of collecting a complete set of different items by purchasing randomized packs.



"""#Sock Drawer Problem"""

#This function simulates the process of drawing socks from a drawer until a matching pair is found.
import random

def simulate_sock_drawer_problem(n, simulations):
    total_draws = 0
#Initializes a counter called (total_draws) to keep track of the total number of draws across all simulations.

    for _ in range(simulations):
        socks = {}
        draws = 0
#Initializes an empty dictionary called (socks) to track the count of each sock color.
#Initializes a counter called (draws) to count the number of draws in this simulation.

        while True:
            # Randomly draw a sock
            sock_color = random.randint(1, n)
            draws += 1

            # Update the count for this color
            if sock_color in socks:
                socks[sock_color] += 1
            else:
                socks[sock_color] = 1

            # Check for a pair
            if socks[sock_color] == 2:
                break

        total_draws += draws

    # Calculate the average number of draws needed
    average_draws_needed = total_draws / simulations
    return average_draws_needed
#Calculates the average number of draws needed to find a matching pair.

# Number of pairs of socks
n = 10

# Number of simulations
simulations = 10000

# Calculate the expected number of draws
expected_draws = simulate_sock_drawer_problem(n, simulations)
expected_draws
#This simulation models the problem of drawing socks from a drawer until a matching pair is obtained.